 Это готовый проект и информация о Spring WebFlux. Можно дополнять

 # Spring WebFlux — реактивный архитектурный подход, не путать с обычным асинхронным кодом
    Асинхронный код — не ждёт завершения операции
    Реактивный код — управляет потоком данных, реагирует на события
 # Реактивный подход:
    Поток не ждёт, операция выполняется асинхронно
    Результат приходит позже, как событие
    Данные приходят сами, когда они реально готовы
 #CPU-bound vs I/O-bound
    CPU-bound — основное время тратится на вычисления, ограничено процессором
    I/O-bound — основное время тратится на ожидание внешних ресурсов (HTTP, DB, Kafka)
    Реактивность особенно полезна для I/O-bound задач
 #Параллельная обработка
    Задача может выполняться на разных потоках
    Хорошая утилизация ресурсов → можно выжать максимум из железа
    Сложнее разрабатывать, дебажить и тестировать

    Publisher - производит события, Flux/Mono любой источник данных
    Subscriber - подписывается на Publisher и получает события - subscribe(), в проекте это HTTP клиент, например Postman
    Subscription - подписка на получение данных - request(n)
    Backpressure - Балансировка скорости Publisher ↔ Subscriber - limitRate(), onBackpressureBuffer()

ленивая загрузка данных - данные не загружаются сразу, а только тогда, когда они реально нужны, и часто по частям (streaming)
Flux<User> users = repository.findAll(); // пока никто не подписался — ничего не делает
users.subscribe(System.out::println); // Данные реально придут только при subscribe()
поддержка websocket

Event Loop — модель выполнения, где один поток обрабатывает множество задач, переключаясь между ними без блокировок
Переключение между задачами нужно, потому что ожидание — это пустая трата CPU
Cold publisher - аналогия со стриминговым сервисом, каждый пользователь смотрит/делает остановку фильма для себя
Hot publisher - аналог классического телевизора

throughput - работы в единицу времени
latency - время от старта запроса до получения ответа
Часто оптимизация throughput ухудшает latency, и наоборот

обычное Spring приложение работает в нескольких потоках: Tomcat / Jetty создают thread pool
Каждый HTTP-запрос обрабатывается отдельным потоком - Параллельные запросы → параллельные потоки
Это называется thread-per-request








для spring boot не нужно указывать в пропертях класс драйвер, по урлу БД подключиться нужный драйвер
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb

не нужно в коде запускать миграцию, она запускается сама перед hibernate, нужна зависимость и верное расположение файлов resources/db/migration
implementation("org.flywaydb:flyway-core")
Для PostgreSQL иногда также нужно: implementation("org.flywaydb:flyway-database-postgresql")

подключение minio в powershift: minio server C:\minio\data --console-address :9001

